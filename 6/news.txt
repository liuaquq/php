1.本节的代码是一个可以适合各种类型的顺序表，之所以能够适合各种类型，是因为它在顺序表中保存的是元素的地址(其实就是一个指针数组)。
2.代码中的描述顺序表的结构体中的元素介绍：length是顺序表中有元素的个数、capacity是顺序表的容量、node是顺序表的头地址(也是这个指针数组的头地址)、还有一个就是pos，pos是在删除和插入的时候使用的一个参数，它代表的是插入到顺序表位置的下标(数组的下标 是从0开始的 这个很要注意)。顺序表中有length个元素 下标是从0到length-1的。要注意的是 操作顺序表不同功能函数的pos的允许范围是不一样的。
3.本节代码对于函数参数的合法性判断是极其重视的，这个规范是值得学习的。
4.本节代码中对于顺序表的操作函数，凡是外界输入的，和输出到外界的，都是void *类型的，这样就保证了只有在这些操作函数中才能去改变   描述顺序表的结构体里面的值，在其他文件的函数中接受到的都是void *类型，无法直接给这个结构体中的值进行改变，这样的封装，保证了代码的安全性。
5.对于本节代码最值得思考的地方，常见的顺序表是typedef一个A类型，然后在顺序表中定义一个这个A类型的数组和length顺序表元素个数，这个顺序表中是好多个A类型的顺序集合，占用空间的大小是sizeof(A)*capacity。而本节的顺序表中是好多个unsigned int *地址类型的顺序集合，表中只有地址，第一节省了顺序表的空间，第二这样可以变相的保存不同类型的数据，第三它实现了 顺序表(即数据结构) 和 我们打算利用的数据(即元素)的分离。例如：linux内核链表(一个双向循环链表)就是一套单独的链表体制，这个链表用在很多机制上面，它就是变相的存储了好多类型的数据，并且实现了链表和数据的分离。
所以在main.c中  数据要想保存在这个顺序表中  就应该先给这些数据开辟内存    因为顺序表中没有他们呆的地方   顺序表中只能保存他们的地址。